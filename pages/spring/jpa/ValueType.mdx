# 값 타입
값 타입은 3가지로 나눌 수 있다.

### 기본값 타입
- 자바 기본 타입(int, double)
- 래퍼 클래스(Integer)
- String
### 임베디드 타입(복합값 타입)
### 컬렉션 값 타입

# 기본값 타입
- int, double 같은 기본 타입, 엔티티에 의존

# 임베디드 타입
- 새로운 값 타입은 직접 정의해서 사용
- 아래와 같이 주소에 대한 정보를 분리하여 코드에 대한 응집력을 높인다.
- @Embeddable: 값 타입을 정의하는 곳에 표시
- @Embedded: 값 타입을 사용하는 곳에 표시
- 임베디드 타입은 기본 생성자가 필수다.
- 엔티티와 임베디드 타입의 관계를 UML로 표현하면 컴포지션 관계가 된다.
```
@Embeddable
public class Address {
    @Column(name = "city")
    private String city;
    private String detail;
}

```

# @AttributeOverride
- 임베디드 타입에 정의한 매핑정보를 재정의한다.
- 집주소나 회사주소 등 추가로 필요할 경우 컬럼명이 중복될 경우 재정의한다.
- name: 기존 컬럼명
- column: 새로운 컬럼명

# 값 타입과 불변 객체
값 타입을 공유하면 A의 타입만 변경할려고 하는데 B의 타입도 변경되는 Side Effect가 발생할 수 있다. 이와 같은 부작용을 방지하기 위해<br />
값을 복사해서 사용하면 된다.

## 값 타입 복사
아래와 같이 값을 공유하는 것이 아닌 복사해서 사용하면 된다. 허나 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 *객체타입*이다.<br />
자바에서 기본 타입은 값을 복사하여 넘기지만 객체는 참조값을 전달한다. 물론 객체를 대입할 때 마다 인스턴스를 복사해서 대입하면 공유 참조를 막을 수 있다/<br />
허나 문제는 복사하지 않고 원본의 참조 값을 직접 넘기는 것을 막을 방법이 없다는 것이다. 객체의 공유 참조는 피할 수 없다.<br />
따라서 가장 단순하게 방법은 객체를 수정하지 못하게 한다.

``` java

Address address = member.getAddress();

// 값을 복사하여 새로운 Address를 생성
Address newAddress = address.clone();

newAddress.setName('New Name');

// 회원2의 주소에 대해서만 UPDATE SQL 실행
member2.setAddress(newAddress);

```

## 불변 객체
객체를 불변으로 만들 면 값을 수정할 수 없으므로 부작용을 원천 차단할 수 있기 때문에 값 타입은 될 수 있으면 불볍 객체로 설계해야한다.
정리하자면 불변이라는 작은 제약으로 사이드이펙트라는 큰 재앙을 막을 수 있다.

## 동등성과 동일성
- 동일성 비교: 인스턴스의 참조 값을 비교, == 사용
- 동등성 비교: 인스턴스의 값을 비교, equals() 사용

