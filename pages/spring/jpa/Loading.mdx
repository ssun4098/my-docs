# 즉시로딩
- 엔티티를 조회할 때 연관된 엔티티도 함꼐 조회한다.
- 설정방법: @ManyToOne(fetch = FetchType.EAGER)
- 대부분의 JPA 구현체는 즉시 로딩에 최적화하기 위해 조인 쿼리를 사용
- 연관관계가 nullable 값이 true면 외부 조인을, false면 내부 조인을 실행한다.(null 제약조건과 조인전략)

# 지연로딩
- 연관된 엔티티를 실제 사용할 때 조회한다.
- 설정방법: @ManyToOne(fetch = FetchType.LAZY)
- 

# 정리

## 지연 로딩
- 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.

## 즉시로딩
- 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다.

# 컬렉션 래퍼
- 엔티티를 연속상태로 만들 때 엔티티에 컬렉션이 있으면 내장 컬렉션으로 변경하는데 이것을 컬렉션 래퍼라고 한다.
- 엔티티를 지연로딩하면 프록시 객체가 지연로딩 처리해준다면 컬렉션은 컬렉션 래퍼가 처리해준다.
- member.getOrders()처럼 컬렉션에 접근하는 것이 아닌 mbmer.getOrders().get(0)처럼 직접 데이터에 접근할 때 DB에서 조회해서 가져온다.

# JPA 기본 페치 전략
- @ManyToOne, @OneToOne: 즉시 로딩(FetchType.EAGER)
- @OneToMany, @ManyToMany: 지연 로딩(FetchType.LAZY)

추천하는 방법은 처음에는 모두 지연 로딩처리 후 어느정도 왼성된 후 실제 사용하는 상황을 보고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화한다.
만약 SQL을 직접 사용한다면 조인으로 한 번에 조회하면 최적화에 불리하다.

# 컬렉션에 FetchType.EAGER 주의 사항
- 컬렉션을 하나 이상 즉시로딩하는 것은 권장하지 않는다. 문제는 서로 다른 컬렉션을 2개 이상 조인할 때 SQL 결과가 N * M이 되면서 너무 많은 데이터를 반환할 수 있다. JPA는 이렇게 조회된 결과를 메모리에서 필터링해서 반환한다. 따라서 2개 이상의 컬렉션을 즉시 로딩으로 설정하는 것은 권장하지 않는다.
- 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다. 만약 일대다 관계에서 다쪽에 데이터가 하나도 없다면 일의 데이터를 조회할 수 없기 때문이다.